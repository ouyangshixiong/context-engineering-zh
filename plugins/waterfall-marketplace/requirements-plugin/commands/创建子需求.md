---
description: 将Jira系统中已创建的用户故事（Story）进行结构化分解，明确每个子需求的业务目标、功能边界，形成可执行的子需求（Subtask），并关联上下文的JIRA的story。以支持后续开发与测试阶段的工作衔接。文档遵循Waterfall/V模型的需求分解规范，仅生成Markdown格式的需求文档，不包含代码或配置内容。
---

# 创建子需求 Command

## 核心原则

### 统一父级结构
- **父级统一为Story**: 所有子需求和开发任务都挂在对应Story下
- **便于统计**: 便于统计Story完成度和Sprint Burn-down

### 类型统一与语义区分
- **统一使用Subtask类型**: 所有子需求和开发任务都使用Subtask类型
- **标签区分语义**:
  - `label = "requirement"` → 子需求（Sub-requirement）
  - `label = "implementation"` → 开发任务（Task）

### 可追溯性
- **链接关系**: 每个开发任务通过"Relates"链接关联到对应的子需求
- **逻辑链**: 在JQL或插件中形成完整的逻辑链：Story → 子需求 → 开发任务
- **自动链接**: 开发任务创建时自动链接到对应的子需求

## 工作流程

1. 读取jira.md中的jira的JIRA_DOMAIN、user-email和auth-token，如果没有这个配置文件，提示用户输入JIRA_DOMAIN、user-email和auth-token并创建jira.md配置文件
2. 根据example先获取所属story内部ID
3. 将requirements目录中关联story（功能需求）的子需求格式化，模仿`scripts/create_subtask.py`创建jira的Subtask
4. **Subtask内容充实**
   - 调用 `enrich_subtasks_content.py` 充实Subtask内容
   - 为每个子需求(Subtask)填充业务目标、功能边界、技术实现路径和验收标准
   - 根据任务类型应用合适的模板



## 子需求编号规范

子需求将按照以下规范自动生成编号：
- **格式**: `REQ-[StoryKey]-[序号]`
- **示例**: 如果Story是`CMT-5`，第一个子需求将是`REQ-CMT-5-1`
- **显示**: 编号会显示在子需求的Summary中，格式为`[REQ-CMT-5-1] 任务描述`

这个编号规范有助于：
- 清晰标识父子关系
- 便于搜索和过滤
- 保持需求管理的规范性

# example

## 获取所有jira项目的project_id
'''
curl -u {user-email}:{auth-token} \
  -X GET \
  -H "Accept: application/json" \
  "https://ouyangshixiong.atlassian.net/rest/api/3/project/search"
'''

## 列出项目支持的issue type
'''
curl -u {user-email}:{auth-token} \
  -X GET \
  -H "Content-Type: application/json" \
  "https://ouyangshixiong.atlassian.net/rest/api/3/issuetype/project?projectId={PROJECTID}"
'''

## 获取story的内部ID
curl -u "{user-email}:{auth-token}" \
  -X GET \
  -H "Accept: application/json" \
  "https://ouyangshixiong.atlassian.net/rest/api/3/issue/CMT-5" | jq -r '.id'

# rule
使用Atlassian Document格式